/**
 * 一：
 * 阻塞与非阻塞：
 *      进程在访问数据的时候，数据是否准备就绪的一种处理方式。
 *                  阻塞：等数据在缓冲区准备好才处理其他事情，否则一直等待。
 *                  非阻塞：不论数据是否准备好，都直接返回。
 * 同步与异步：
 *      同步和异步都是基于应用程序和操作系统处理io事件所采用的方式。
 *                  同步应用程序需要直接参与io读写的操作。
 *                          同步的方式在处理io时间的时候，必须阻塞在某个方法上面等待io操作完成。当没有数据的时候，需要阻塞到read或者write方法上面，不能做自己的事情。
 *                          于是可以将读写另起线程，对线程的开销损耗还是很大的。
 *                                  可以阻塞在io或者通过事件轮询的方式。就是多路复用技术（select模式）。将读写事件交给一个单独的线程。线程完成io事件的注册功能，不断地去轮询读写缓冲区
 *                                  是否有数据准备好了，准备好了之后就通知相应的读写事件。这样就可以不用阻塞在io线程，只需要阻塞select线程。
 *
 *                  异步应用程序io读写交给操作系统去实现。
 *                          所有的io读写都交给操作系统，应用程序不需要处理io，操作系统完成io之后给应用程序通知就可以了。
 * 二：
 * IO模型：
 * BIO（jdk1.4、阻塞io） 阻塞到读写方法；改进到阻塞线程来改进性能，会有线程开销造成性能浪费；
 * NIO（多路复用技术：select模式）实现io事件的轮询方式。同步非阻塞。（mina，netty）
 * AIO（jdk1.7 NIO2.0）这里才是真正的异步。学习了linux的epoll模式。
 *
 * 三：
 * 原理：
 * 对于网络通信而言，并没有改变网络通关系的基本流程，只是在原来的基础上（socket和serverSocket）做了改进。
 * 原来的socket和serverSocket建立连接是面向连接的，需要三次握手的确认机制来建立稳定的连接，性能开销比较大。
 * 解决方案：思路是减少连接的次数，对读写通信管道进项抽象（channel：在tcp连接上的抽象，可以一对多，减少连接的次数。）。
 * NIO:selector多路复用技术，相当于一个管家，管理所有io事件：客户端的connect、服务端的accept、客户端和服务端的读写。
 *      如何管理：当io事件注册给选择器的时候，选择器会给他们分配一个key值，当作事件的标签。当io事件就绪的时候，会通过key值找到相应的管道，然后通过管道发送、接收数据等操作。
 *数据缓冲区：Buffer，主要通过byteBuffer来实现。
 *
 *
 */

/**
 * 缓冲区是什么，和内存是什么关系？
 * 什么叫数据准备好了？
 */
package com.cht.testspringboot.io_related;